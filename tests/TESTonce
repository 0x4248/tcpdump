#!/usr/bin/env perl

$TCPDUMP = "../tcpdump" if (!($TCPDUMP = $ENV{TCPDUMP_BIN}));

use File::Basename;
use POSIX qw( WEXITSTATUS WIFEXITED);

system("mkdir -p NEW DIFF");

if(@ARGV != 4) {
  print "Usage: TESTonce name input output options\n";
  exit 20;
}

$name=$ARGV[0];
$input=$ARGV[1];
$output=$ARGV[2];
$options=$ARGV[3];

my $r;

$outputbase = basename($output);
my $coredump = false;
my $status = 0;

if ($^O eq 'MSWin32') {
    $r = system "..\\windump -# -n -r $input $options 2>NUL | sed 's/\\r//' | tee NEW/$outputbase | diff $output - >DIFF/$outputbase.diff";
    # need to do same as below for Cygwin.
}
else {
    # we used to do this as a nice pipeline, but the problem is that $r fails to
    # to be set properly if the tcpdump core dumps.
    $r = system "$TCPDUMP 2>NEW/$outputbase.stderr -# -n -r $input $options >NEW/$outputbase";
    if($r != 0) {
        my $coredump = false;
        my $status = 0;
        # this means tcpdump failed.
        open(OUTPUT, ">>"."NEW/$outputbase") || die "fail to open $outputbase\n";
        if( $r & 128 ) {
            $coredump = $r & 127;
        }
        if( WIFEXITED($r)) {
            $status = WEXITSTATUS($r);
        }

        printf OUTPUT "EXIT CODE %08x: dump:%d code: %d\n", $r, $coredump, $status;
        close(OUTPUT);
        $r = 0;
    }
    if($r == 0) {
        $r = system "cat NEW/$outputbase | diff $output - >DIFF/$outputbase.diff";
    }
    #print sprintf("END: %08x\n", $r);
}

if($r == 0) {
  printf "    %-35s: passed\n", $name;
  unlink "DIFF/$outputbase.diff";
  exit 0;
}
printf "    %-35s: TEST FAILED(%s)", $name, $r == -1 ? $! : "exit core=$coredump/stat=$status";
open FOUT, '>>failure-outputs.txt';
printf FOUT "\nFailed test: $name\n\n";
close FOUT;
if(-f "DIFF/$outputbase.diff") {
    system "cat DIFF/$outputbase.diff >> failure-outputs.txt";
}

if($r == -1) {
  print " (failed to execute: $!)\n";
  exit 30;
}

# this is not working right, $r == 0x8b00 when there is a core dump.
# clearly, we need some platform specific perl magic to take this apart, so look for "core"
# too.
# In particular, on Solaris 10 SPARC an alignment problem results in SIGILL,
# a core dump and $r set to 0x00008a00 ($? == 138 in the shell).
if($r & 127 || -f "core") {
    my $with = ($r & 128) ? 'with' : 'without';
    if(-f "core") {
        $with = "with";
    }
    printf " (terminated with signal %u, %s coredump)\n", ($r & 127), $with;
    exit ($r & 128) ? 10 : 20;
}
print "\n";
exit $r >> 8;
